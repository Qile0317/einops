% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/packing.R
\name{pack}
\alias{pack}
\title{Packs several tensors into one.}
\usage{
pack(
  tensors,
  pattern,
  return_ps = getOption("einops_pack_return_ps", TRUE),
  ...
)
}
\arguments{
\item{tensors}{Tensors to be packed. Can be of different dimensionality.}

\item{pattern}{Pattern shared for all inputs and output, e.g. \code{"i j * k"}
or \code{"batch seq *"}.}
}
\value{
A list containing the packed tensor and packed shapes (PS).
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

This function can pack a list of tensors into a single tensor based
on the \code{pattern}, comprising of a sequence of letters and one asterisk.
See the vignette for more information on how this all works.

This function's output is a list of length 2, with the first element
being the actually packed tensor, and the second being a list of
integers indicating the packed shapes, a nice piece of syntactic sugar
for assigning these results is to use the \code{zeallot::"\%<-\%"} operator
to assign 2 variables like such: \code{c(packed, ps) \%<-\% pack(x, "a b *")}
}
\examples{
library(zeallot)
inputs <- list(
    array(0, c(2, 3, 5)),
    array(0, c(2, 3, 7, 5)),
    array(0, c(2, 3, 7, 9, 5))
)
packed, ps \%<-\% pack(inputs, 'i j * k')
# the line above is identical to assigning each of those
# variables to the first and second elements of the output

print(dim(packed))
#> c(2, 3, 71, 5)
print(ps)
#> list(integer(), 7, c(7, 9))

# In this example, axes were matched to: i=2, j=3, k=5 based on order
# (first, second, and last). All other axes were 'packed' and
# concatenated. PS (packed shapes) contains information about axes
# matched to '*' in every input. The resulting tensor has as many
# elements as all inputs in total.

# Packing can be reversed with unpack, which additionally needs PS
# (packed shapes) to reconstruct order.

# inputs_unpacked <- unpack(packed, ps, 'i j * k')
# [x.shape for x in inputs_unpacked]
# [(2, 3, 5), (2, 3, 7, 5), (2, 3, 7, 9, 5)]

# Read the tutorial for introduction and application
}
\seealso{
\code{\link[=unpack]{unpack()}}
}
\keyword{internal}
